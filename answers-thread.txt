简单题，抄 xv6 进程调度的代码就可以，打开 user/uthread.c
user/uthread_switch.S 里面就更简单了，直接拷贝 kernel 里面的 switch.S 文件
给哈希表加锁，保证并发安全

送分题，打开 ph.c 文件

...
int keys[NKEYS];
int nthread = 1;

// 为每个 bucket 创建一个锁
pthread_mutex_t locks[NBUCKET];
...

static 
void put(int key, int value)
{
  ...
  if(e){
    // update the existing key.
    e->value = value;
  } else {
    // the new is new.
    pthread_mutex_lock(&locks[i]); // 加锁
    insert(key, value, &table[i], table[i]);
    pthread_mutex_unlock(&locks[i]); // 解锁
  }
}

int
main(int argc, char *argv[])
{
  ...
  if (argc < 2) {
    fprintf(stderr, "Usage: %s nthreads\n", argv[0]);
    exit(-1);
  }
  // 初始化所有锁
  for(int i = 0; i < NBUCKET; i++) {
      pthread_mutex_init(&locks[i], NULL);
  }
  nthread = atoi(argv[1]);
  ...
}
实现一个 “屏障”（barrier）：所有的线程都需要在 barrier 这个同步点等待，直到所有线程都到达这个点之后才可以继续向下执行。

又是送分题，打开 notxv6/barrier.c 文件